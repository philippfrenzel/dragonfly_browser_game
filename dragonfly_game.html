<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Libellen‚ÄëRunner</title>
  <style>
    :root {
      --bg: #0b1623;
      --hud: #e6f2ff;
      --accent: #7fd1ff;
      --accent-2: #a0ffcf;
      --danger: #ff6b6b;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 600px at 50% 10%, #12263a 0%, var(--bg) 60%);
      color: var(--hud);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    .wrap {
      width: min(100vw, 1000px);
      aspect-ratio: 16/9;
      position: relative;
      border-radius: 16px;
      box-shadow: 0 10px 35px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.04);
      overflow: hidden;
      background: linear-gradient(#93d8ff 0%, #4ab6ff 40%, #2f71a5 41%, #154c77 100%);
    }
    canvas { width: 100%; height: 100%; display: block; background: transparent; }
    .hud {
      position: absolute; top: 10px; left: 12px; right: 12px;
      display: flex; justify-content: space-between; align-items: center;
      font-weight: 600; text-shadow: 0 2px 10px rgba(0,0,0,.45);
      user-select: none; pointer-events: none;
    }
    .tag { padding: 6px 10px; background: rgba(0,0,0,.25); border-radius: 999px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.07); }
    .overlay { position: absolute; inset: 0; display: grid; place-items: center; background: radial-gradient(1000px 400px at 50% 10%, rgba(0,0,0,.15), rgba(0,0,0,.55)); text-align: center; padding: 24px; }
    .card { background: rgba(255,255,255,.95); border-radius: 16px; padding: 24px 22px; box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08); backdrop-filter: blur(6px); max-width: 720px; color: #003b4a; }
    .powerup-indicator { 
      position: absolute; 
      bottom: 10px; 
      left: 12px; 
      display: flex; 
      gap: 10px; 
    }
    .powerup-icon {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      font-weight: bold;
      color: #00233a;
      box-shadow: 0 3px 8px rgba(0,0,0,.3);
      position: relative;
    }
    .powerup-timer {
      position: absolute;
      bottom: -5px;
      right: -5px;
      background: rgba(0,0,0,.5);
      color: white;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      font-size: 10px;
      display: grid;
      place-items: center;
    }
    .shield { background: linear-gradient(180deg, #7fd1ff 0%, #5cc8ff 100%); }
    .speed { background: linear-gradient(180deg, #ff7f7f 0%, #ff5c5c 100%); }
    .magnet { background: linear-gradient(180deg, #ffd36b 0%, #ffb347 100%); }
    h1 { margin: 0 0 8px 0; font-size: clamp(22px, 2.4vw, 36px); letter-spacing: .5px; }
    p { margin: 6px 0; opacity: .95; }
    kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: rgba(0,137,137,.12); padding: 2px 6px; border-radius: 6px; border: 1px solid rgba(0,137,137,.25); }
    .btn { display: inline-block; margin-top: 14px; padding: 10px 16px; border-radius: 999px; font-weight: 700; letter-spacing: .3px; color: white; background: linear-gradient(180deg, #00aaa0 0%, #008989 100%); box-shadow: 0 8px 16px rgba(0,0,0,.25); text-decoration: none; pointer-events: auto; }
    .btn:active { transform: translateY(1px); }
    .touch-hint { display: none; }
    @media (pointer: coarse) { .touch-hint { display: inline; } }
    .name-input { width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(0,137,137,.25); margin-top: 14px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game"></canvas>
    <div class="hud">
      <div class="tag">Score: <span id="score">0</span></div>
      <div class="tag">Best: <span id="best">0</span></div>
      <div class="tag">Speed: <span id="speed">1.0x</span></div>
    </div>
    <div class="powerup-indicator" id="powerupIndicator"></div>
    <div class="overlay" id="overlay">
      <div class="card">
        <div style="text-align: center; margin-bottom: 15px;">
          <img src="logo.png" alt="Libellen-Runner Logo" width="220" height="100" style="margin-bottom: 5px;" />
        </div>
        <h1>Runner</h1>
        <p>Fliege als Libelle √ºber den Fluss, weiche Zahlenreihen, Seerosen und V√∂geln aus, sammle M√ºcken‚ÄëOrbs f√ºr Bonuspunkte.</p>
        <p><strong>Power-Ups:</strong> üõ°Ô∏è Schutzschild ¬∑ üî• Geschwindigkeitsschub ¬∑ üß≤ M√ºcken-Magnet</p>
        <p><strong>Steuerung:</strong> <kbd>Leertaste</kbd> oder <kbd>‚Üë</kbd> Fl√ºgelschlag / Sprung ¬∑ <kbd>P</kbd> Pause ¬∑ <span class="touch-hint">Tippen f√ºr Fl√ºgelschlag</span></p>
        <input type="text" id="playerNameInput" class="name-input" placeholder="Wie hei√üt du?">
        <a href="#" class="btn" id="start">Losfliegen</a>
      </div>
    </div>
  </div>

<script>
(function() {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start');
    const nameInput = document.getElementById('playerNameInput');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const speedEl = document.getElementById('speed');
    const powerupIndicatorEl = document.getElementById('powerupIndicator');

  // Powerup Typen
  const POWERUP_TYPES = {
    SHIELD: 'shield',
    SPEED_BOOST: 'speedBoost',
    MAGNET: 'magnet'
  };

  // Powerup-Konfiguration
  const POWERUP_CONFIG = {
    [POWERUP_TYPES.SHIELD]: {
      duration: 8,
      color: 'rgba(127,209,255,0.9)',
      icon: 'üõ°Ô∏è',
      class: 'shield'
    },
    [POWERUP_TYPES.SPEED_BOOST]: {
      duration: 6,
      color: 'rgba(255,127,127,0.9)',
      icon: 'üî•',
      class: 'speed'
    },
    [POWERUP_TYPES.MAGNET]: {
      duration: 10,
      color: 'rgba(255,200,100,0.9)',
      icon: 'üß≤',
      class: 'magnet'
    }
  };

  let DPR = Math.max(1, window.devicePixelRatio || 1);
  const state = {
    running: false,
    paused: false,
    t: 0,
    score: 0,
    best: Number(localStorage.getItem('dragonfly-best') || 0),
    speed: 1,
    baseSpeed: 320, // px/s world scroll speed
    worldOffset: 0,
    activePowerups: {}, // Aktive Powerups speichern
    playerName: '',
    topDown: false,
    topDownStartScore: 0
  };
  bestEl.textContent = state.best;

  const world = { w: 960, h: 540, riverY: 0.45 };

  function resize() {
    const rect = canvas.getBoundingClientRect();
    world.w = Math.floor(rect.width * DPR);
    world.h = Math.floor(rect.height * DPR);
    canvas.width = world.w; canvas.height = world.h;
  }
  resize(); addEventListener('resize', resize);

  // Input
  const input = { flap: 0, left: 0, right: 0 }; let justFlapped = false;
  function onPress() { input.flap = 1; justFlapped = true; }
  function onRelease() { input.flap = 0; }
  addEventListener('keydown', (e) => {
    if (!state.topDown && (e.code === 'Space' || e.code === 'ArrowUp')) { e.preventDefault(); onPress(); }
    else if (state.topDown && e.code === 'ArrowLeft') { e.preventDefault(); input.left = 1; }
    else if (state.topDown && e.code === 'ArrowRight') { e.preventDefault(); input.right = 1; }
    else if (e.code === 'KeyP') togglePause();
    else if (e.code === 'Enter' && !state.running) start();
  });
  addEventListener('keyup', (e) => {
    if (!state.topDown && (e.code === 'Space' || e.code === 'ArrowUp')) onRelease();
    else if (state.topDown && e.code === 'ArrowLeft') { input.left = 0; }
    else if (state.topDown && e.code === 'ArrowRight') { input.right = 0; }
  });
  canvas.addEventListener('pointerdown', onPress);
  addEventListener('pointerup', onRelease);
  startBtn.addEventListener('click', (e) => { e.preventDefault(); start(); });

  function togglePause() {
    if (!state.running) return;
    state.paused = !state.paused;
    overlay.style.display = state.paused ? 'grid' : 'none';
    if (!state.paused) lastTs = performance.now();
  }

  // Entities
  function rand(min, max) { return Math.random() * (max - min) + min; }
  const player = { 
    x: 0, y: 0, vx: 0, vy: 0, 
    r: 18, g: 1400, flapVel: -520, maxVy: 680, 
    invuln: 0,
    hasShield: false, 
    hasSpeedBoost: false,
    hasMagnet: false 
  };
  const obstacles = []; const pickUps = []; const powerups = []; const clouds = [];

  function reset() {
    state.t = 0; state.score = 0; state.speed = 1; state.worldOffset = 0; state.topDown = false; state.baseSpeed = 320; state.topDownStartScore = 0;
    state.activePowerups = {};
    speedEl.textContent = '1.0x';
    obstacles.length = 0; pickUps.length = 0; powerups.length = 0;
    player.x = world.w * 0.22; player.y = world.h * 0.5; 
    player.vx = 0; player.vy = 0; player.invuln = 0;
    player.hasShield = false; player.hasSpeedBoost = false; player.hasMagnet = false;
    spawnTimer = 0; orbTimer = 1.5; powerupTimer = 5;
    lastObstacleTime = 0;
    powerupIndicatorEl.innerHTML = '';
    
    // Wolken initialisieren
    clouds.length = 0;
    initClouds();
  }

  function initClouds() {
    // 5-10 zuf√§llige Wolken erstellen
    const numClouds = 5 + Math.floor(Math.random() * 6);
    for (let i = 0; i < numClouds; i++) {
      clouds.push({
        x: Math.random() * world.w * 1.5, // √úber die gesamte Breite + etwas mehr verteilen
        y: 50 + Math.random() * 120,      // H√∂he √ºber den Bergen
        size: 0.4 + Math.random() * 0.6,  // Zuf√§llige Gr√∂√üe
        speed: 0.05 + Math.random() * 0.1, // Unterschiedliche Geschwindigkeiten
        opacity: 0.6 + Math.random() * 0.3 // Unterschiedliche Transparenz
      });
    }
  }

  // Spawning
  let spawnTimer = 0; let orbTimer = 1.5; let powerupTimer = 5;
  let lastObstacleTime = 0; // Vermeidung von zu dicht aufeinanderfolgenden Hindernissen
  function spawnObstacle() {
    const river = world.h * world.riverY;
    // 3 Hindernistypen: vertikale Hindernisse, Seerosen und V√∂gel
    const rnd = Math.random();
    const type = rnd < 0.5 ? 'reed' : (rnd < 0.8 ? 'waterLily' : 'bird');
    
    if (type === 'reed') {
      const gap = rand(180, 240); // Gr√∂√üere L√ºcke zwischen den Zahlenreihen
      const center = rand(river - 60, river + 60);
      const thickness = rand(25, 35); // Breite der Zahlenreihen-W√§nde
      obstacles.push({ type: 'reed', x: world.w + 40, width: thickness, gap, center, passed: false });
    } else if (type === 'waterLily') {
      // Gr√∂√üenbereich f√ºr Seerosen
      const size = rand(40, 65);
      const y = river + rand(70, 120);
      obstacles.push({ type: 'waterLily', x: world.w + 40, y, size, passed: false });
    } else if (type === 'bird') {
      // V√∂gel erscheinen im oberen Bereich
      const size = rand(28, 40);
      const y = rand(river - 180, river - 40);
      // V√∂gel bewegen sich auch vertikal
      const vertSpeed = rand(30, 80) * (Math.random() > 0.5 ? 1 : -1);
      const vertAmp = rand(20, 60);
      obstacles.push({ 
        type: 'bird', 
        x: world.w + 40, 
        y, 
        size, 
        passed: false,
        vertSpeed,
        vertAmp,
        initY: y
      });
    }
  }
  
  function spawnOrb() {
    const river = world.h * world.riverY;
    const y = rand(river - 110, river + 110);
    const rnd = Math.random();
    let type, value;
    if (rnd < 0.6) { type = 'bronze'; value = 5; }
    else if (rnd < 0.9) { type = 'silver'; value = 10; }
    else { type = 'gold'; value = 40; }
    pickUps.push({ x: world.w + 40, y, r: 10, type, value });
  }

  function spawnPowerup() {
    const river = world.h * world.riverY;
    const y = rand(river - 140, river - 20); // Powerups erscheinen eher im oberen Bereich
    
    // Powerup-Typ zuf√§llig ausw√§hlen
    const types = Object.values(POWERUP_TYPES);
    const type = types[Math.floor(Math.random() * types.length)];
    
    powerups.push({ 
      type,
      x: world.w + 40, 
      y, 
      r: 15
    });
  }

  // Rendering helpers
  function drawBackground() {
    if (state.topDown) {
      drawBackgroundTopDown();
      return;
    }

    const w = world.w, h = world.h; const p = state.worldOffset * 0.15; ctx.save();

    // Himmel - leichter Verlauf
    const skyGradient = ctx.createLinearGradient(0, 0, 0, h * 0.36);
    skyGradient.addColorStop(0, '#a7d8f8');
    skyGradient.addColorStop(1, '#d7eeff');
    ctx.fillStyle = skyGradient;
    ctx.fillRect(0, 0, w, h * 0.36);

    // Wolken zeichnen
    for (const cloud of clouds) {
      drawCloud(cloud.x, cloud.y, cloud.size, cloud.opacity);
    }

    if (state.score < 150) {
      // Mountains - SWICA T√ºrkist√∂ne
      for (let i = 0; i < 2; i++) {
        const baseY = h * (0.36 + i * 0.05);
        ctx.fillStyle = i === 0 ? '#00aaa0' : '#008989';
        ctx.beginPath();
        const offset = (p * (i + 1)) % w;
        ctx.moveTo(-offset, baseY);
        for (let x = -offset; x <= w - offset + 200; x += 200) {
          const peakHeight = 80 + i * 30 + Math.sin((x + i * 123) * 0.01) * 20;
          ctx.lineTo(x + 100, baseY - peakHeight);
          ctx.lineTo(x + 200, baseY);
        }
        ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath(); ctx.fill();
      }
    } else if (state.score < 250) {
      // City skyline
      for (let i = 0; i < 2; i++) {
        const baseY = h * (0.36 + i * 0.05);
        ctx.fillStyle = i === 0 ? '#7a8a8f' : '#607074';
        const offset = (p * (i + 1)) % w;
        for (let x = -offset; x < w + 120; x += 120) {
          const bWidth = 60 + i * 20;
          const bHeight = 80 + i * 40 + Math.sin((x + i * 45) * 0.02) * 20;
          ctx.fillRect(x, baseY - bHeight, bWidth, bHeight);
        }
      }
    } else {
      // Desert with dunes
      const groundY = h * world.riverY;
      ctx.fillStyle = '#edc76c';
      ctx.fillRect(0, groundY, w, h - groundY);
      for (let i = 0; i < 2; i++) {
        const baseY = h * (0.36 + i * 0.05);
        ctx.fillStyle = i === 0 ? '#e0b55b' : '#d1a14a';
        ctx.beginPath();
        const offset = (p * (i + 1)) % w;
        ctx.moveTo(-offset, baseY);
        for (let x = -offset; x <= w - offset + 200; x += 200) {
          const duneHeight = 40 + i * 20 + Math.sin((x + i * 87) * 0.01) * 15;
          ctx.lineTo(x + 100, baseY - duneHeight);
          ctx.lineTo(x + 200, baseY);
        }
        ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath(); ctx.fill();
      }
      // Cacti
      const cactusOffset = (state.worldOffset * 0.6) % 160;
      for (let x = -cactusOffset; x < w + 160; x += 160) drawCactus(x, groundY, 1);
      ctx.restore();
      return;
    }
    // River
    const riverY = h * world.riverY; ctx.fillStyle = '#1a6aa1'; ctx.fillRect(0, riverY, w, h - riverY);
    ctx.globalAlpha = 0.35; ctx.fillStyle = '#79d3ff';
    const waveOffset = (state.worldOffset * 0.6) % 40;
    for (let x = -waveOffset; x < w + 50; x += 40) {
      ctx.fillRect(x, riverY + 24, 24, 3);
      ctx.fillRect(x + 10, riverY + 52, 18, 3);
      ctx.fillRect(x - 6, riverY + 84, 28, 3);
    }
    ctx.globalAlpha = 1;
    // Foreground number sequences (parallax)
    const reedOffset = (state.worldOffset * 1.2) % 80;
    for (let x = -reedOffset; x < w + 80; x += 80) drawReedCluster(x, riverY + 6, 1);
    ctx.restore();
  }

  function drawBackgroundTopDown() {
    const w = world.w, h = world.h;
    if (state.score < 150) {
      ctx.fillStyle = '#1a6aa1';
    } else if (state.score < 250) {
      ctx.fillStyle = '#7a8a8f';
    } else {
      ctx.fillStyle = '#edc76c';
    }
    ctx.fillRect(0, 0, w, h);
  }

  function drawCactus(x, baseY, scale) {
    ctx.save();
    ctx.translate(x, baseY);
    ctx.scale(scale, scale);
    ctx.fillStyle = '#2f8f2f';
    // main trunk
    ctx.fillRect(-5, -40, 10, 40);
    // left arm
    ctx.fillRect(-15, -30, 10, 5);
    ctx.fillRect(-20, -45, 5, 20);
    // right arm
    ctx.fillRect(5, -25, 10, 5);
    ctx.fillRect(15, -40, 5, 20);
    // rounded top
    ctx.beginPath();
    ctx.arc(0, -40, 5, Math.PI, 0);
    ctx.fill();
    ctx.restore();
  }
  
  function drawReedCluster(x, baseY, scale) {
    ctx.save(); ctx.translate(x, baseY); ctx.scale(scale, scale);
    
    // Zuf√§llige Zahlenreihen statt Gr√§ser
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    
    // F√ºr jede "Spalte" im ehemaligen Grascluster
    for (let i = 0; i < 5; i++) {
      const h = 50 + i * 8; // H√∂he beibehalten f√ºr √§hnliche Verteilung
      const column = i * 10; // Horizontale Position mit etwas mehr Abstand
      
      // Verwende eine Pseudozufallszahl basierend auf der Position
      // So bleiben die Zahlen bei jedem Durchlauf gleich
      const seed = Math.sin(x * 0.1 + i * 0.3) * 10000;
      
      // Zeichne 5-8 Zahlen in einer S√§ule
      const numDigits = 5 + Math.floor(Math.abs(Math.sin(seed * 0.4)) * 3);
      for (let j = 0; j < numDigits; j++) {
        // Pseudozuf√§llige Zahl zwischen 0-9, aber deterministisch pro Position
        const digit = Math.floor(Math.abs(Math.sin(seed + j * 0.7) * 10)) % 10;
        
        // Vertikale Position - besser verteilt von unten nach oben
        const yPos = -5 - (h * j / (numDigits - 1));
        
        // Farben variieren f√ºr visuellen Effekt
        const hue = Math.abs(Math.sin(seed + j * 0.5) * 60) + 140; // T√ºrkis bis Blaut√∂ne
        const lightness = 40 + Math.abs(Math.sin(seed + j * 0.3) * 30);
        ctx.fillStyle = `hsla(${hue}, 70%, ${lightness}%, 0.85)`;
        
        // Zeichne die Zahl
        ctx.fillText(digit.toString(), column, yPos);
      }
    }
    
    ctx.restore();
  }

  function drawStripedRect(x, y, w, h) {
    const stripe = 10;
    for (let i = 0; i < h; i += stripe) {
      ctx.fillStyle = (i / stripe) % 2 === 0 ? '#ff5555' : '#ffffff';
      ctx.fillRect(x, y + i, w, Math.min(stripe, h - i));
    }
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, w, h);
  }

  function drawCityBarrier(o) {
    const topH = Math.max(0, o.center - o.gap/2);
    const bottomY = o.center + o.gap/2;
    drawStripedRect(o.x, 0, o.width, topH);
    drawStripedRect(o.x, bottomY, o.width, world.h - bottomY);
  }

  function drawSignRect(x, y, w, h) {
    ctx.fillStyle = '#f2c94c';
    ctx.strokeStyle = '#b98b2c';
    ctx.lineWidth = 2;
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x, y, w, h);
    ctx.save();
    ctx.translate(x + w/2, y + h/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillStyle = '#000';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Vorsicht', 0, -5);
    ctx.fillText('W√ºste', 0, 15);
    ctx.restore();
  }

  function drawDesertSign(o) {
    const topH = Math.max(0, o.center - o.gap/2);
    const bottomY = o.center + o.gap/2;
    drawSignRect(o.x, 0, o.width, topH);
    drawSignRect(o.x, bottomY, o.width, world.h - bottomY);
  }

  function drawWaterLily(x, y, size) {
    ctx.save();
    ctx.translate(x, y);

    if (state.score < 150) {
      drawWaterLilyShape(size);
    } else if (state.score < 250) {
      if (state.topDown) drawScooterTop(size); else drawScooter(size);
    } else {
      if (state.topDown) drawLionTop(size); else drawLion(size);
    }

    ctx.restore();
  }

  function drawWaterLilyShape(size) {
    // Schatten unter der Seerose
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 5;
    ctx.beginPath();
    ctx.ellipse(0, 5, size*0.9, size*0.3, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fill();
    ctx.shadowColor = 'transparent';

    // Seerosenblaetter (3-4 Bl√§tter)
    const numLeaves = 3 + Math.floor(Math.random() * 2);
    for (let i = 0; i < numLeaves; i++) {
      const angle = (i / numLeaves) * Math.PI * 2;
      const leafSize = size * (0.7 + Math.random() * 0.3);

      ctx.save();
      ctx.rotate(angle);

      // Blattform
      ctx.fillStyle = '#1e8c39';
      ctx.beginPath();
      ctx.ellipse(leafSize*0.4, 0, leafSize*0.6, leafSize*0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      // Blattadern
      ctx.strokeStyle = '#156626';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(leafSize*0.7, 0);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(leafSize*0.3, -leafSize*0.2);
      ctx.quadraticCurveTo(leafSize*0.5, 0, leafSize*0.3, leafSize*0.2);
      ctx.stroke();

      ctx.restore();
    }

    // Seerose Bl√ºte
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(0, 0, size*0.25, 0, Math.PI * 2);
    ctx.fill();

    // Bl√ºtenbl√§tter
    const numPetals = 8;
    for (let i = 0; i < numPetals; i++) {
      const angle = (i / numPetals) * Math.PI * 2;
      const petalLength = size * 0.25;

      ctx.save();
      ctx.rotate(angle);
      ctx.translate(size*0.2, 0);

      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.ellipse(0, 0, petalLength, petalLength*0.4, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // Bl√ºtenmitte
    ctx.fillStyle = '#ffda0d';
    ctx.beginPath();
    ctx.arc(0, 0, size*0.12, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawScooter(size) {
    const scale = size / 60;
    ctx.save();
    ctx.scale(scale, scale);

    // R√§der
    ctx.fillStyle = '#555';
    ctx.beginPath();
    ctx.arc(-20, 20, 10, 0, Math.PI*2);
    ctx.arc(20, 20, 10, 0, Math.PI*2);
    ctx.fill();

    // Trittbrett
    ctx.fillStyle = '#333';
    ctx.fillRect(-25, 10, 50, 6);

    // Lenkerstange
    ctx.fillStyle = '#555';
    ctx.fillRect(0, -40, 4, 50);

    // Lenker
    ctx.fillStyle = '#777';
    ctx.fillRect(-8, -44, 20, 4);

    ctx.restore();
  }

  function drawLion(size) {
    const scale = size / 60;
    ctx.save();
    ctx.scale(scale, scale);

    // K√∂rper
    ctx.fillStyle = '#d8a81f';
    ctx.beginPath();
    ctx.ellipse(0, 10, 30, 18, 0, 0, Math.PI*2);
    ctx.fill();

    // M√§hne
    ctx.fillStyle = '#a05a2c';
    ctx.beginPath();
    ctx.arc(0, -20, 25, 0, Math.PI*2);
    ctx.fill();

    // Kopf
    ctx.fillStyle = '#d8a81f';
    ctx.beginPath();
    ctx.arc(0, -20, 15, 0, Math.PI*2);
    ctx.fill();

    // Gesicht
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-5, -22, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(5, -22, 2, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#a05a2c';
    ctx.beginPath();
    ctx.arc(0, -17, 3, 0, Math.PI*2);
    ctx.fill();

    // Beine
    ctx.fillStyle = '#d8a81f';
    ctx.fillRect(-20, 20, 8, 15);
    ctx.fillRect(12, 20, 8, 15);

    // Schwanz
    ctx.strokeStyle = '#d8a81f';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(30, 10);
    ctx.quadraticCurveTo(40, 0, 45, 15);
    ctx.stroke();
    ctx.fillStyle = '#a05a2c';
    ctx.beginPath();
    ctx.arc(45, 15, 5, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
  }

  function drawScooterTop(size) {
    const scale = size / 60;
    ctx.save();
    ctx.scale(scale, scale);

    ctx.fillStyle = '#333';
    ctx.fillRect(-25, -5, 50, 10);

    ctx.fillStyle = '#555';
    ctx.beginPath();
    ctx.arc(-20, 0, 8, 0, Math.PI * 2);
    ctx.arc(20, 0, 8, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#777';
    ctx.fillRect(-2, -40, 4, 35);
    ctx.fillRect(-10, -40, 20, 4);
    ctx.restore();
  }

  function drawLionTop(size) {
    const scale = size / 60;
    ctx.save();
    ctx.scale(scale, scale);

    ctx.fillStyle = '#a05a2c';
    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#d8a81f';
    ctx.beginPath();
    ctx.arc(0, 0, 20, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(-8, -5, 3, 0, Math.PI * 2);
    ctx.arc(8, -5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
  
  function drawStone(x, y, size) {
    // Vergr√∂√üere die Steine um 40%
    size = size * 1.4;
    
    ctx.save(); 
    ctx.translate(x, y); 
    
    // Hauptform des Steins
    ctx.fillStyle = '#5f6d7a';
    ctx.beginPath(); 
    ctx.moveTo(-size*0.6, 0);
    ctx.quadraticCurveTo(-size*0.2, -size*0.6, size*0.5, -size*0.3);
    ctx.quadraticCurveTo(size*0.7, 0, -size*0.6, 0); 
    ctx.fill();
    
    // Zus√§tzliche Details f√ºr den Stein
    // Dunkle Konturen f√ºr Tiefe
    ctx.strokeStyle = '#3a424a';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-size*0.5, -size*0.1);
    ctx.lineTo(-size*0.3, -size*0.4);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-size*0.2, -size*0.3);
    ctx.lineTo(size*0.4, -size*0.2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(size*0.5, -size*0.3);
    ctx.lineTo(size*0.7, 0);
    ctx.stroke();
    
    ctx.restore();
  }

  // Orb zeichnen (M√ºcken)
  function drawOrb(o, t) {
    ctx.save();
    ctx.translate(o.x, o.y + Math.sin(t * 6 + o.x*0.02) * 6);
    const colors = {
      bronze: { inner: 'rgba(205,127,50,0.9)', outer: 'rgba(205,127,50,0)', core: '#ffe0b2' },
      silver: { inner: 'rgba(192,192,192,0.9)', outer: 'rgba(192,192,192,0)', core: '#f2f2f2' },
      gold:   { inner: 'rgba(255,215,0,0.9)',   outer: 'rgba(255,215,0,0)',   core: '#fff5b5' }
    };
    const c = colors[o.type] || colors.bronze;
    const g = ctx.createRadialGradient(0,0,0,0,0,20);
    g.addColorStop(0, c.inner);
    g.addColorStop(1, c.outer);
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(0,0,18,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = c.core;
    ctx.beginPath();
    ctx.arc(0,0,6,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // Vogel als neues Hindernis
  function drawBird(x, y, size, t) {
    ctx.save();
    ctx.translate(x, y);

    const wingFlap = Math.sin(t * 15) * 0.5;
    if (state.topDown) {
      if (state.score >= 150 && state.score < 250) {
        drawSeagullTop(size, wingFlap);
      } else {
        drawDefaultBirdTop(size, wingFlap);
      }
    } else {
      if (state.score >= 150 && state.score < 250) {
        drawSeagullBody(size, wingFlap);
      } else {
        drawDefaultBirdBody(size, wingFlap);
      }
    }

    ctx.restore();
  }

  function drawDefaultBirdBody(size, wingFlap) {
    // K√∂rper
    ctx.fillStyle = '#78552b';
    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.7, size*0.4, 0, 0, Math.PI*2);
    ctx.fill();

    // Kopf
    ctx.fillStyle = '#94683a';
    ctx.beginPath();
    ctx.arc(size*0.5, -size*0.3, size*0.3, 0, Math.PI*2);
    ctx.fill();

    // Schnabel
    ctx.fillStyle = '#e09f3e';
    ctx.beginPath();
    ctx.moveTo(size*0.8, -size*0.3);
    ctx.lineTo(size*1.2, -size*0.35);
    ctx.lineTo(size*0.8, -size*0.2);
    ctx.closePath();
    ctx.fill();

    // Auge
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(size*0.6, -size*0.35, size*0.08, 0, Math.PI*2);
    ctx.fill();

    // Fl√ºgel oben
    ctx.fillStyle = '#8b653d';
    ctx.save();
    ctx.translate(0, -size*0.2);
    ctx.rotate(wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.8, size*0.3, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Fl√ºgel unten
    ctx.fillStyle = '#8b653d';
    ctx.save();
    ctx.translate(0, size*0.2);
    ctx.rotate(-wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.8, size*0.3, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Schwanz
    ctx.fillStyle = '#94683a';
    ctx.beginPath();
    ctx.moveTo(-size*0.6, 0);
    ctx.lineTo(-size*1.2, -size*0.2);
    ctx.lineTo(-size*1.2, size*0.2);
    ctx.closePath();
    ctx.fill();
  }

  function drawSeagullBody(size, wingFlap) {
    // K√∂rper
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.7, size*0.4, 0, 0, Math.PI*2);
    ctx.fill();

    // Kopf
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath();
    ctx.arc(size*0.5, -size*0.3, size*0.25, 0, Math.PI*2);
    ctx.fill();

    // Schnabel
    ctx.fillStyle = '#ffce00';
    ctx.beginPath();
    ctx.moveTo(size*0.7, -size*0.3);
    ctx.lineTo(size*1.1, -size*0.28);
    ctx.lineTo(size*0.7, -size*0.22);
    ctx.closePath();
    ctx.fill();

    // Auge
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(size*0.55, -size*0.35, size*0.07, 0, Math.PI*2);
    ctx.fill();

    // Fl√ºgel oben
    ctx.fillStyle = '#d0d0d0';
    ctx.save();
    ctx.translate(0, -size*0.1);
    ctx.rotate(wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.9, size*0.3, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Fl√ºgel unten
    ctx.fillStyle = '#d0d0d0';
    ctx.save();
    ctx.translate(0, size*0.1);
    ctx.rotate(-wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size*0.9, size*0.3, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();

    // Schwanz
    ctx.fillStyle = '#d0d0d0';
    ctx.beginPath();
    ctx.moveTo(-size*0.6, 0);
    ctx.lineTo(-size*1.0, -size*0.2);
    ctx.lineTo(-size*1.0, size*0.2);
    ctx.closePath();
    ctx.fill();
  }

  function drawDefaultBirdTop(size, wingFlap) {
    ctx.fillStyle = '#94683a';
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#8b653d';
    ctx.save();
    ctx.rotate(wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 1.4, size * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.rotate(-wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 1.4, size * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#e09f3e';
    ctx.beginPath();
    ctx.arc(0, -size * 0.7, size * 0.2, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawSeagullTop(size, wingFlap) {
    ctx.fillStyle = '#f0f0f0';
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#d0d0d0';
    ctx.save();
    ctx.rotate(wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 1.5, size * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.rotate(-wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 1.5, size * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#ffce00';
    ctx.beginPath();
    ctx.arc(0, -size * 0.7, size * 0.18, 0, Math.PI * 2);

    ctx.restore();

    // Schwanz
    ctx.fillStyle = '#d0d0d0';
    ctx.beginPath();
    ctx.moveTo(-size*0.6, 0);
    ctx.lineTo(-size*1.0, -size*0.2);
    ctx.lineTo(-size*1.0, size*0.2);
    ctx.closePath();

    ctx.fill();
  }

  // Powerup zeichnen
  function drawPowerup(p, t) {
    const config = POWERUP_CONFIG[p.type];
    const wobble = Math.sin(t * 6 + p.x*0.02) * 6;
    ctx.save(); 
    ctx.translate(p.x, p.y + wobble);
    
    // √Ñu√üere Leuchteffekt
    const g = ctx.createRadialGradient(0,0,0,0,0,25);
    g.addColorStop(0, config.color);
    g.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(0,0,22,0,Math.PI*2);
    ctx.fill();

    // Innerer Kern
    ctx.fillStyle = config.color.replace('0.9', '1');
    ctx.beginPath();
    ctx.arc(0,0,10,0,Math.PI*2);
    ctx.fill();

    // Glanzeffekt
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.beginPath();
    ctx.arc(-3,-3,3,0,Math.PI*2);
    ctx.fill();

    // Icon in der Mitte zeichnen
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(config.icon, 0, 0);

    ctx.restore();
  }

  // Dragonfly with X-shaped wings and head-forward alignment
  function drawDragonfly(p, t) {
    ctx.save();
    ctx.translate(p.x, p.y);

    const vx = state.baseSpeed * state.speed; // approximate forward velocity
    const angle = Math.atan2(p.vy, vx);
    ctx.rotate(angle);

    const thoraxRadius = 6;
    const abdomenLen = 46;
    const headR = 8;

    const flapFore = Math.sin(t * 36) * 0.12;      // front pair
    const flapHind = Math.sin(t * 36 + 1.2) * 0.12; // rear pair with phase offset

    // Spine
    ctx.strokeStyle = '#7fe0ff';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-abdomenLen, 0);
    ctx.lineTo(0, 0);
    ctx.lineTo(headR + 6, 0);
    ctx.stroke();

    // Thorax
    ctx.fillStyle = '#39d4ff';
    ctx.beginPath();
    ctx.ellipse(0, 0, thoraxRadius + 2, thoraxRadius, 0, 0, Math.PI * 2);
    ctx.fill();

    // Abdomen segments (tapered)
    for (let i = 0; i < 7; i++) {
      const x = -i * (abdomenLen / 7);
      const w = Math.max(2, 5 - i * 0.6);
      ctx.fillStyle = i % 2 ? '#1ec4ff' : '#3fd7ff';
      ctx.fillRect(x - 2, -w, 4, w * 2);
    }

    // Head (front)
    ctx.fillStyle = '#a0ffcf';
    ctx.beginPath(); ctx.arc(headR + 6, 0, headR, 0, Math.PI * 2); ctx.fill();
    // Eyes
    ctx.fillStyle = '#003b4a';
    ctx.beginPath(); ctx.arc(headR + 10, -3, 3, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(headR + 10,  3, 3, 0, Math.PI * 2); ctx.fill();

    // Wings (X-shape)
    const wingFill = 'rgba(255,255,255,0.5)';
    const wingStroke = 'rgba(255,255,255,0.85)';

    function wing(angle, len, spread, flap) {
      ctx.save();
      ctx.rotate(angle + flap);
      ctx.fillStyle = wingFill; ctx.strokeStyle = wingStroke; ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.moveTo(0, 0);
      ctx.quadraticCurveTo(len * 0.42, -spread, len, 0);
      ctx.quadraticCurveTo(len * 0.42,  spread, 0, 0);
      ctx.fill(); ctx.stroke();
      // simple veins
      ctx.beginPath();
      ctx.moveTo(0, 0); ctx.lineTo(len * 0.65, 0);
      ctx.moveTo(len * 0.28, -spread * 0.55); ctx.lineTo(len * 0.6, -spread * 0.15);
      ctx.moveTo(len * 0.28,  spread * 0.55); ctx.lineTo(len * 0.6,  spread * 0.15);
      ctx.stroke();
      ctx.restore();
    }

    // Forewings (forward-angled: \ /)
    const foreLen = 58, foreSpread = 12;
    wing(+Math.PI/4, foreLen, foreSpread,  flapFore);
    wing(-Math.PI/4, foreLen, foreSpread, -flapFore);

    // Hindwings (backward-angled: / \)
    const hindLen = 54, hindSpread = 13;
    wing(Math.PI - Math.PI/4, hindLen, hindSpread,  flapHind);
    wing(-Math.PI + Math.PI/4, hindLen, hindSpread, -flapHind);

    // Root highlight
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath(); ctx.arc(0, 0, 2.4, 0, Math.PI * 2); ctx.fill();

    ctx.restore();
  }

  function drawDragonflyTop(p, t) {
    ctx.save();
    ctx.translate(p.x, p.y);

    const wingFlap = Math.sin(t * 30) * 0.25;

    // Body
    ctx.fillStyle = '#39d4ff';
    ctx.beginPath();
    ctx.ellipse(0, 0, 6, 20, 0, 0, Math.PI * 2);
    ctx.fill();

    // Head
    ctx.fillStyle = '#a0ffcf';
    ctx.beginPath();
    ctx.arc(0, -14, 6, 0, Math.PI * 2);
    ctx.fill();

    // Wings
    const wingFill = 'rgba(255,255,255,0.5)';
    const wingStroke = 'rgba(255,255,255,0.85)';
    ctx.fillStyle = wingFill;
    ctx.strokeStyle = wingStroke;
    ctx.lineWidth = 1;

    ctx.save();
    ctx.rotate(wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, 30, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.rotate(-wingFlap);
    ctx.beginPath();
    ctx.ellipse(0, 0, 30, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function circleRectCollision(cx, cy, r, rx, ry, rw, rh) {
    const nx = Math.max(rx, Math.min(cx, rx + rw));
    const ny = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - nx, dy = cy - ny; return (dx*dx + dy*dy) <= r*r;
  }

  // Powerup aktivieren
  function activatePowerup(type) {
    const config = POWERUP_CONFIG[type];
    
    // Wenn dieser Powerup-Typ bereits aktiv ist, Zeit verl√§ngern
    if (state.activePowerups[type]) {
      state.activePowerups[type].timeLeft = config.duration;
      const timerEl = document.querySelector(`#powerup-${type} .powerup-timer`);
      if (timerEl) timerEl.textContent = Math.ceil(config.duration);
      return;
    }
    
    // Powerup speichern
    state.activePowerups[type] = {
      timeLeft: config.duration,
      config: config
    };
    
    // Spieler-Status anpassen
    switch(type) {
      case POWERUP_TYPES.SHIELD:
        player.hasShield = true;
        break;
      case POWERUP_TYPES.SPEED_BOOST:
        player.hasSpeedBoost = true;
        state.baseSpeed *= 1.4; // 40% schneller
        break;
      case POWERUP_TYPES.MAGNET:
        player.hasMagnet = true;
        break;
    }
    
    // Powerup-Anzeige erstellen
    const indicatorEl = document.createElement('div');
    indicatorEl.id = `powerup-${type}`;
    indicatorEl.className = `powerup-icon ${config.class}`;
    indicatorEl.innerHTML = `
      ${config.icon}
      <div class="powerup-timer">${Math.ceil(config.duration)}</div>
    `;
    powerupIndicatorEl.appendChild(indicatorEl);
  }
  
  // Powerup deaktivieren
  function deactivatePowerup(type) {
    if (!state.activePowerups[type]) return;
    
    // Spieler-Status zur√ºcksetzen
    switch(type) {
      case POWERUP_TYPES.SHIELD:
        player.hasShield = false;
        player.invuln = 1; // Kurze Unverwundbarkeit nach Shield-Verlust
        break;
      case POWERUP_TYPES.SPEED_BOOST:
        player.hasSpeedBoost = false;
        state.baseSpeed /= 1.4; // Geschwindigkeit zur√ºcksetzen
        break;
      case POWERUP_TYPES.MAGNET:
        player.hasMagnet = false;
        break;
    }
    
    // Powerup aus aktivem Status entfernen
    delete state.activePowerups[type];
    
    // UI-Element entfernen
    const indicatorEl = document.getElementById(`powerup-${type}`);
    if (indicatorEl) {
      powerupIndicatorEl.removeChild(indicatorEl);
    }
  }

  function start() {
    if (!state.playerName) {
      const entered = nameInput ? nameInput.value.trim() : '';
      state.playerName = entered || 'Gast';
    }
    overlay.style.display = 'none'; state.running = true; state.paused = false; reset(); lastTs = performance.now(); requestAnimationFrame(loop);
  }
  function gameOver() {
    state.running = false; state.paused = false;
    if (state.score > state.best) { state.best = state.score; localStorage.setItem('dragonfly-best', String(state.best)); }
    bestEl.textContent = state.best;
    overlay.innerHTML = `<div class="card">
        <div style="text-align: center; margin-bottom: 15px;">
          <img src="logo.png" alt="Libellen-Runner Logo" width="220" height="100" style="margin-bottom: 5px;" />
        </div>
        <h1>Game Over, ${state.playerName}!</h1>
        <p>Score: <strong>${Math.floor(state.score)}</strong> ¬∑ Best: <strong>${state.best}</strong></p>
        <p><small>Tipp: kurze, rhythmische Fl√ºgelschl√§ge geben dir mehr Kontrolle.</small></p>
        <a href="#" class="btn" id="restart">Nochmal</a>
        <a href="#" class="btn" id="resetGame" style="margin-left:10px;">Neustart</a>
      </div>`;
    overlay.style.display = 'grid';
    overlay.querySelector('#restart').addEventListener('click', (e) => { e.preventDefault(); start(); });
    overlay.querySelector('#resetGame').addEventListener('click', (e) => { e.preventDefault(); location.reload(); });
  }

  let lastTs = performance.now();
  function loop(ts) {
    if (!state.running) return; const dt = Math.min(0.033, (ts - lastTs) / 1000); lastTs = ts; if (state.paused) { requestAnimationFrame(loop); return; }
    update(dt); render(); requestAnimationFrame(loop);
  }

  function update(dt) {
    state.t += dt;
    if (!state.topDown && state.score >= 400) {
      state.topDown = true;
      state.baseSpeed = 320;
      state.topDownStartScore = state.score;
    }
    const progressScore = state.topDown ? state.score - state.topDownStartScore : state.score;
    state.speed = 1 + Math.min(1.2, Math.max(0, progressScore) / 150);
    speedEl.textContent = `${state.speed.toFixed(1)}x`;
    const scroll = state.baseSpeed * state.speed * dt; state.worldOffset += scroll;

    if (state.topDown) {
      const move = 360 * dt;
      if (input.left) player.y -= move;
      if (input.right) player.y += move;
      const minY = 30, maxY = world.h - 30;
      if (player.y < minY) player.y = minY;
      if (player.y > maxY) player.y = maxY;
      player.vy = 0;
    } else {
      if (justFlapped) { player.vy = player.flapVel; justFlapped = false; }
      player.vy += player.g * dt; player.vy = Math.min(player.vy, player.maxVy); player.y += player.vy * dt;
      const minY = 30, maxY = world.h - 30; if (player.y < minY) { player.y = minY; player.vy = 0; } if (player.y > maxY) { player.y = maxY; player.vy = 0; }
    }
    if (player.invuln > 0) player.invuln -= dt;
    
    // Powerup Timer verarbeiten
    Object.keys(state.activePowerups).forEach(type => {
      const powerup = state.activePowerups[type];
      powerup.timeLeft -= dt;
      
      // Powerup-Anzeige aktualisieren
      const indicatorEl = document.getElementById(`powerup-${type}`);
      if (indicatorEl) {
        const timerEl = indicatorEl.querySelector('.powerup-timer');
        if (timerEl) {
          timerEl.textContent = Math.ceil(powerup.timeLeft);
        }
      }
      
      // Powerup beenden, wenn abgelaufen
      if (powerup.timeLeft <= 0) {
        deactivatePowerup(type);
      }
    });
    


    // Spawn Timer
    spawnTimer -= dt; 
    lastObstacleTime += dt;
    if (spawnTimer <= 0) { 
      // Mindestens 1,2 Sekunden zwischen Hindernissen (skaliert mit Spielgeschwindigkeit)
      if (lastObstacleTime >= 1.2 / state.speed) {
        spawnObstacle(); 
        lastObstacleTime = 0;
      }
      spawnTimer = rand(1.2, 2.0) / state.speed; // Etwas l√§ngere Pausen zwischen Hindernissen
    }
    orbTimer -= dt; if (orbTimer <= 0) { spawnOrb(); orbTimer = rand(1.5, 3.0) / state.speed; }
    powerupTimer -= dt; if (powerupTimer <= 0) { spawnPowerup(); powerupTimer = rand(8.0, 15.0); }

    for (let i = obstacles.length - 1; i >= 0; i--) {
      const o = obstacles[i]; o.x -= scroll;
      
      // Spezielle Bewegung f√ºr V√∂gel
      if (o.type === 'bird') {
        o.y = o.initY + Math.sin(state.t * o.vertSpeed / 100) * o.vertAmp;
      }
      
      if (o.type === 'reed') {
        const topH = Math.max(0, o.center - o.gap/2); const bottomY = o.center + o.gap/2;
        const hitTop = circleRectCollision(player.x, player.y, player.r, o.x, 0, o.width, topH);
        const hitBottom = circleRectCollision(player.x, player.y, player.r, o.x, bottomY, o.width, world.h - bottomY);
        if ((hitTop || hitBottom) && player.invuln <= 0) {
          if (player.hasShield) {
            deactivatePowerup(POWERUP_TYPES.SHIELD);
          } else {
            return gameOver();
          }
        }
        if (!o.passed && o.x + o.width < player.x) { state.score += 1; o.passed = true; }
      } else if (o.type === 'waterLily') {
        // Kollisionsbereich f√ºr Seerosen
        const adjustedSize = o.size;
        if (circleRectCollision(player.x, player.y, player.r, o.x - adjustedSize*0.8, o.y - adjustedSize*0.4, adjustedSize*1.6, adjustedSize*0.8) && player.invuln <= 0) {
          if (player.hasShield) {
            deactivatePowerup(POWERUP_TYPES.SHIELD);
          } else {
            return gameOver();
          }
        }
        if (!o.passed && o.x < player.x) { state.score += 1; o.passed = true; }
      } else if (o.type === 'bird') {
        // Vogel-Kollision pr√ºfen (runde Hitbox)
        const dist = Math.hypot(player.x - o.x, player.y - o.y);
        if (dist < player.r + o.size*0.5 && player.invuln <= 0) {
          if (player.hasShield) {
            deactivatePowerup(POWERUP_TYPES.SHIELD);
          } else {
            return gameOver();
          }
        }
        if (!o.passed && o.x < player.x) { state.score += 1; o.passed = true; }
      }
      if (o.x < -200) obstacles.splice(i, 1);
    }

    for (let i = pickUps.length - 1; i >= 0; i--) {
      const p = pickUps[i]; 
      
      // Magnet zieht Orbs an
      if (player.hasMagnet) {
        const dx = player.x - p.x;
        const dy = player.y - p.y;
        const dist = Math.hypot(dx, dy);
        if (dist < 200) {  // Magnet-Reichweite
          const pullSpeed = 400;  // Anziehungsgeschwindigkeit
          const moveX = (dx / dist) * pullSpeed * dt;
          const moveY = (dy / dist) * pullSpeed * dt;
          p.x += moveX;
          p.y += moveY;
        } else {
          p.x -= scroll * 1.05;
        }
      } else {
        p.x -= scroll * 1.05;
      }
      
      if (Math.hypot(player.x - p.x, player.y - p.y) < player.r + p.r) {
        const basePoints = p.value;
        const points = player.hasSpeedBoost ? basePoints * 2 : basePoints;
        state.score += points;
        player.invuln = 0.6;
        pickUps.splice(i, 1);
        continue;
      }
      if (p.x < -40) pickUps.splice(i, 1);
    }
    
    // Powerups pr√ºfen
    for (let i = powerups.length - 1; i >= 0; i--) {
      const p = powerups[i];
      p.x -= scroll * 1.05;
      
      if (Math.hypot(player.x - p.x, player.y - p.y) < player.r + p.r) {
        activatePowerup(p.type);
        powerups.splice(i, 1);
        continue;
      }
      
      if (p.x < -40) powerups.splice(i, 1);
    }
    
    scoreEl.textContent = Math.floor(state.score);
  }

  function render() {
    ctx.clearRect(0,0,world.w,world.h);
    ctx.save();

    if (state.topDown) {
      ctx.translate(world.w / 2, world.h / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.translate(-world.w / 2, -world.h / 2);
    }

    drawBackground();

    const t = state.t;
    
    // Hindernisse zeichnen
    for (const o of obstacles) {
      if (o.type === 'reed') {
        if (state.score < 150) {
          ctx.fillStyle = '#2e7d32';
          ctx.fillRect(o.x, 0, o.width, Math.max(0, o.center - o.gap/2));
          ctx.fillStyle = '#4caf50';
          ctx.fillRect(o.x, Math.max(0, o.center - o.gap/2) - 10, o.width, 10);
          const bottomY = o.center + o.gap/2;
          ctx.fillStyle = '#2e7d32';
          ctx.fillRect(o.x, bottomY, o.width, world.h - bottomY);
          ctx.fillStyle = '#4caf50';
          ctx.fillRect(o.x, bottomY, o.width, 10);
        } else if (state.score < 250) {
          drawCityBarrier(o);
        } else {
          drawDesertSign(o);
        }
      } else if (o.type === 'waterLily') {
        drawWaterLily(o.x, o.y, o.size);
      } else if (o.type === 'bird') {
        drawBird(o.x, o.y, o.size, t);
      }
    }
    
    // Orbs zeichnen
    for (const p of pickUps) drawOrb(p, t);
    
    // Powerups zeichnen
    for (const p of powerups) drawPowerup(p, t);

    // Spieler (blink when invulnerable)
    if (player.invuln > 0) {
      if (((t * 20) | 0) % 2 === 0) {
        state.topDown ? drawDragonflyTop(player, t) : drawDragonfly(player, t);
      }
    }
    else {
      state.topDown ? drawDragonflyTop(player, t) : drawDragonfly(player, t);
    }
    
    // Shield-Effekt um Spieler zeichnen, wenn aktiv
    if (player.hasShield) {
      ctx.save();
      ctx.translate(player.x, player.y);
      const pulseSize = 1 + Math.sin(t * 5) * 0.1;
      ctx.scale(pulseSize, pulseSize);
      
      ctx.beginPath();
      ctx.arc(0, 0, player.r + 8, 0, Math.PI*2);
      
      const gradient = ctx.createRadialGradient(0, 0, player.r, 0, 0, player.r + 8);
      gradient.addColorStop(0, 'rgba(127, 209, 255, 0.0)');
      gradient.addColorStop(0.7, 'rgba(127, 209, 255, 0.3)');
      gradient.addColorStop(1, 'rgba(127, 209, 255, 0.7)');
      
      ctx.fillStyle = gradient;
      ctx.fill();
      
      ctx.strokeStyle = 'rgba(127, 209, 255, 0.9)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.restore();
    }
    
    // Speed-Boost Effekt
    if (player.hasSpeedBoost) {
      ctx.save();
      ctx.translate(player.x, player.y);
      
      // Trail hinter der Libelle
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const alpha = 0.7 - i * 0.08;
        const size = player.r - i * 1.5;
        const offset = i * 14;
        
        ctx.fillStyle = `rgba(255, 100, 100, ${alpha})`;
        ctx.beginPath();
        ctx.arc(-offset, 0, size, 0, Math.PI*2);
        ctx.fill();
      }
      
      ctx.restore();
    }

    // Shadow
    const minY = 30, maxY = world.h - 30;
    const altitudeFactor = (player.y - minY) / (maxY - minY);
    const shadowScale = 0.5 + altitudeFactor * (1.5 - 0.5);

    const baseShadowY = world.h * world.riverY + 120;
    const basePlayerY = world.h * 0.5;
    const maxShadowY = world.h - 10;
    let shadowY = baseShadowY;
    if (player.y > basePlayerY) {
      const downFactor = (player.y - basePlayerY) / (maxY - basePlayerY);
      shadowY = baseShadowY + downFactor * (maxShadowY - baseShadowY);
    }

    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = '#001b2b';
    ctx.beginPath();
    ctx.ellipse(player.x + 6, shadowY, 28 * shadowScale, 6 * shadowScale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
    ctx.restore();
  }
  
  function drawCloud(x, y, size, opacity) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(size, size);
    
    // Weichere Wolkenfarbe mit anpassbarer Transparenz
    ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
    
    // Hauptk√∂rper der Wolke (mehrere √ºberlappende Kreise f√ºr eine weichere Form)
    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI * 2);
    ctx.arc(25, -10, 25, 0, Math.PI * 2);
    ctx.arc(45, 0, 20, 0, Math.PI * 2);
    ctx.arc(65, -5, 15, 0, Math.PI * 2);
    ctx.arc(10, 10, 28, 0, Math.PI * 2);
    ctx.arc(35, 15, 22, 0, Math.PI * 2);
    ctx.arc(55, 10, 18, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
  }
})();
</script>
</body>
</html>
